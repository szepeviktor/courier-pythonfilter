#!/usr/bin/python

# This python application impliments the courierfilter API so that
# filters can be written in python without bothering with the details.

# All filters which plug in to this application should impliment a
# function called 'dofilter'.  All filters should be thread-safe, so
# if you are using global module variables, protect them with a mutex
# before you access them.


##############################
##############################

import os
import sys
import select
import socket
import string
import thread
import time
import traceback

##############################
# Config Options
##############################

# filters_dir is the directory from which python filters will be loaded
filters_dir = sys.prefix + '/lib/pythonfilter'
filters = []

# Set filter_all to 1 if you do not want users to be able to whitelist
# specific senders
filter_all = 1

# Set courier_prefix if you've changed where courier's root is located
courier_prefix = '/usr/lib/courier'
courier_spool = '/var/spool/courier'

##############################
# Initialize filter system
##############################
active_filter_count = 0
af_count_lock = thread.allocate_lock()
if filter_all:
    cf_filterdir = 'allfilters'
else:
    cf_filterdir = 'filters'
cf_socket_prename = '%s/%s/.pythonfilter' % ( courier_spool, cf_filterdir )
cf_socket_name = '%s/%s/pythonfilter' % ( courier_spool, cf_filterdir )
cf_socket_rm1 = '%s/%s/pythonfilter' % ( courier_spool, 'filters' )
cf_socket_rm2 = '%s/%s/pythonfilter' % ( courier_spool, 'allfilters' )

# See if fd #3 is open, indicating that courierfilter is waiting for us
# to notify of init completion.
try:
    os.fstat( 3 )
    notify_after_init = 1
except:
    notify_after_init = 0

# Load filters
try:
    # Insert the filter dir into the search path, so that we can import them.
    sys.path.insert( 0, filters_dir )
    # Only consider modules that begin with a letter and end in '.py'
    for possible_module in os.listdir( filters_dir ):
        if ( len( possible_module ) > 4 and
             possible_module[0] in string.letters and
             possible_module[-3:] == '.py' ):
            try:
                # Seems to be that the only real way to import these bastards
                # is the following, rarely seen format:
                possible_module_obj = __import__( possible_module[:-3] )
                # Store the name of the filter module and a reference to its
                # dofilter function in the "filters" array.
                filters.append( (possible_module, possible_module_obj.dofilter) )
            except AttributeError:
                # Log bad modules
                import_err = sys.exc_info()
                sys.stderr.write( 'Failed to load "dofilter" '
                                  'function from %s\n' %
                                  possible_module )
                sys.stderr.write( 'Exception : %s:%s\n' %
                                  ( import_err[0], import_err[1] ) )
                sys.stderr.write( string.join( traceback.format_tb(import_err[2]), '' ) )
except:
    # If filter loading fails, then just exit
    sys.stderr.write( 'pythonfilter failed to load modules from %s\n' %
                      filters_dir )
    sys.exit()

# Setup socket for courierfilter connection if filters loaded
# completely
try:
    # Remove stale sockets to prevent exceptions
    try: os.unlink( cf_socket_rm1 )
    except: pass
    try: os.unlink( cf_socket_rm2 )
    except: pass
    try: os.unlink( cf_socket_prename )
    except: pass
    cf_socket = socket.socket( socket.AF_UNIX, socket.SOCK_STREAM )
    cf_socket.bind( cf_socket_prename )
    os.rename( cf_socket_prename, cf_socket_name )
    cf_socket.listen( 2 )
except:
    # If the socket creation failed, remove sockets that might
    # exist, so that courier will deliver mail.  It might be best
    # to have courier *not* deliver mail when we fail, but that's
    # not a step I'm ready to take.
    try: os.unlink( cf_socket_prename )
    except: pass
    try: os.unlink( cf_socket_name )
    except: pass
    sys.stderr.write( 'pythonfilter failed to create socket in %s/%s\n' %
                      ( courier_spool, cf_filter_dir ) )
    sys.exit()

# Close fd 3 to notify courierfilter that initialization is complete
if notify_after_init:
    os.close( 3 )


##############################
# Filter loop processing function
##############################
def process_message( cf_sockobj ):
    # Create a file object from the socket so we can read from it
    # using .readline()
    cf_read_lines = cf_sockobj.makefile('r')
    # Read content filename and control filenames from socket
    message_body = string.strip( cf_read_lines.readline() )
    # Normalize file name:
    if message_body[0] != '/':
        message_body = courier_spool + '/tmp/' + message_body
    message_control = []
    while 1:
        message_control_file = cf_read_lines.readline()
        if message_control_file == '\n':
            break
        # Normalize file name:
        if message_control_file[0] != '/':
            message_control_file = ( courier_spool + '/tmp/' +
				     message_control_file )
        message_control.append( string.strip( message_control_file ) )
    # We have nothing more to read from the socket, so se can close
    # the file object
    cf_read_lines.close()
    # Prepare a response message, which is blank initially.  If a filter
    # decides that a message should be rejected, then it must return the
    # reason as an SMTP style response: numeric value and text message.
    # The response can be multiline.
    reply_code = ''
    for i_filter in filters:
        # name = i_filter[0]
        # function = i_filter[1]
        try:
            reply_code = i_filter[1]( message_body, message_control )
        except:
            filter_err = sys.exc_info()
            sys.stderr.write( 'Uncaught exception in "%s" dofilter function: %s:%s\n' %
                              ( i_filter[0], filter_err[0], filter_err[1] ) )
            sys.stderr.write( string.join( traceback.format_tb(filter_err[2]), '' ) )
            reply_code = ''
        if type( '' ) != type( reply_code ):
            sys.stderr.write( '"%s" dofilter function returned non-string\n' % i_filter[0] )
            reply_code = ''
        if reply_code != '':
            break
    # If all modules are ok, accept message
    #  else, write back error code and message
    if reply_code == '':
        cf_sockobj.send( '200 Ok' )
    else:
        cf_sockobj.send( reply_code )
    # Acquire the lock and update the thread count.
    af_count_lock.acquire()
    global active_filter_count
    active_filter_count = active_filter_count - 1
    af_count_lock.release()
    cf_sockobj.close()


##############################
# Listen for connnections on socket
##############################
while 1:
    try: ready_files = select.select( [sys.stdin, cf_socket], [], [] )
    except: continue
    # If stdin raised an event, it was closed and we need to exit.
    if sys.stdin in ready_files[0]:
        break
    if cf_socket in ready_files[0]:
        try:
            cf_sockobj, addr = cf_socket.accept()
            # Now, hand off control to a new thread and continue listening
            # for new connections
            af_count_lock.acquire()
            active_filter_count = active_filter_count + 1
            # Spawn thread and pass filenames as args
            thread.start_new_thread( process_message, (cf_sockobj,)  )
            af_count_lock.release()
        except:
            # Take care of any potential problems after the above block fails
            sys.stderr.write( 'pythonfilter failed to accept connection '
                              'from courierfilter\n' )
            af_count_lock.release()


##############################
# Stop accepting connections when stdin closes, exit when filters are
# complete
##############################
# Dispose of the unix socket
cf_socket.close()
os.unlink( cf_socket_name )
while( active_filter_count > 0 ):
    # Wait for them all to finish
    time.sleep( 0.1 )
